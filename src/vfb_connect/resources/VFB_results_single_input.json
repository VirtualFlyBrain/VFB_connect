{
   "Get JSON for ep_2_anat query":"MATCH (ep:Expression_pattern:Class)&lt;-[ar:overlaps|part_of]-(anoni:Individual)-[:INSTANCEOF]-&gt;(anat:Class) WHERE ep.short_form in ['$ID'] WITH anoni, anat, ar OPTIONAL MATCH (p:pub { short_form: ar.pub}) WITH anat, anoni, { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } AS pub OPTIONAL MATCH (anoni)-[r:Related]-&gt;(o:FBdv) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS stages ,anoni,anat,pub CALL apoc.cypher.run('WITH anat OPTIONAL MATCH (anat:Synaptic_neuropil)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] -&gt;(template:Individual)-[:depicts]-&gt; (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {anat:anat}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, anoni, anat, pub, stages OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,anoni,anat,pub,stages RETURN { short_form: anat.short_form, label: coalesce(anat.label,''), iri: anat.iri, types: labels(anat), unique_facets: apoc.coll.sort(coalesce(anat.uniqueFacets, [])), symbol: coalesce(([]+anat.symbol)[0], '')} AS anatomy, 'Get JSON for ep_2_anat query' AS query, 'd2392ef' AS version , pub, stages, anatomy_channel_image",
   "Get JSON for template_2_datasets query":"MATCH (t:Template)&lt;-[:depicts]-(tc:Template)&lt;-[:in_register_with]-(c:Individual)-[:depicts]-&gt;(ai:Individual)-[:has_source]-&gt;(ds:DataSet) WHERE t.short_form in ['$ID'] WITH distinct ds CALL apoc.cypher.run('WITH ds OPTIONAL MATCH (ds)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] -&gt;(template:Individual)-[:depicts]-&gt; (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {ds:ds}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, ds OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,ds OPTIONAL MATCH (ds)-[rp:has_reference]-&gt;(p:pub) WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS pubs,ds,anatomy_channel_image OPTIONAL MATCH (ds)-[:has_license|license]-&gt;(l:License) WITH collect ({ icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }) as license,ds,anatomy_channel_image,pubs OPTIONAL MATCH (ds)&lt;-[:has_source]-(i:Individual) WITH i, ds, anatomy_channel_image, pubs, license OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) WITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,ds,anatomy_channel_image,pubs,license RETURN { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} as dataset, 'Get JSON for template_2_datasets query' AS query, 'd2392ef' AS version , anatomy_channel_image, pubs, license, dataset_counts",
   "Get JSON for neuron_region_connectivity query":"MATCH (primary) WHERE primary.short_form in ['$ID'] WITH primary MATCH (target:Individual)&lt;-[r:has_presynaptic_terminals_in|has_post_synaptic_terminal_in]-(primary) WITH DISTINCT collect(properties(r)) + {} as props, target, primary WITH apoc.map.removeKeys(apoc.map.merge(props[0], props[1]),['iri', 'short_form', 'Related', 'label', 'type']) as synapse_counts, { short_form: target.short_form, label: coalesce(target.label,''), iri: target.iri, types: labels(target), unique_facets: apoc.coll.sort(coalesce(target.uniqueFacets, [])), symbol: coalesce(([]+target.symbol)[0], '')} as object, target ,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(target) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary,target,synapse_counts, object OPTIONAL MATCH (target)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]-&gt;(template:Individual)-[:depicts]-&gt;(template_anat:Individual) WITH template, channel, template_anat, irw, primary, target, synapse_counts, object, parents OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }}) END AS channel_image,primary,target,synapse_counts, object,parents RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for neuron_region_connectivity query' AS query, 'd2392ef' AS version , synapse_counts, object, parents, channel_image"
}
