{"Get JSON for Individual:Anatomy": "MATCH (primary:Individual:Anatomy) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license]->(l:License) \nWITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link, ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds) }  }, license: { icon : coalesce(l.license_logo, ''), link : coalesce(l.license_url, ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l) }  }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) } ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o)<-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) }  }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: primary.self_xref })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: s.link_base, accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:hasDbXref]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: s.link_base, accession: coalesce(dbx.accession, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)<-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs   OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel) } , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique) } ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template) } , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat) } ,image_folder: irw.folder, index: coalesce(irw.index, []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs OPTIONAL MATCH (o:Individual)<-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) }  }) END AS related_individuals ,primary,dataset_license,parents,relationships,xrefs,channel_image RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary) } , description : coalesce(primary.description, []), comment : coalesce(primary.`annotation-comment`, []) } AS term, 'Get JSON for Individual:Anatomy' AS query, '0f4d3af' AS version , dataset_license, parents, relationships, xrefs, channel_image, related_individuals", "Get JSON for Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) } ) END AS parents ,primary OPTIONAL MATCH (o)<-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) }  }) END AS relationships ,primary,parents OPTIONAL MATCH (o:Individual)<-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) }  }) END AS related_individuals ,primary,parents,relationships OPTIONAL MATCH (s:Site { short_form: primary.self_xref })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: s.link_base, accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, parents, relationships, related_individuals OPTIONAL MATCH (s:Site)<-[dbx:hasDbXref]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: s.link_base, accession: coalesce(dbx.accession, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,parents,relationships,related_individuals OPTIONAL MATCH (primary)-[rp:has_reference { typ: 'syn'}]->(p:pub)  \nWITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p) } , PubMed: coalesce(p.PMID, ''), FlyBase: coalesce(p.FlyBase, ''), DOI: coalesce(p.DOI, '') } , synonym: { label: coalesce(rp.synonym, ''), scope: coalesce(rp.scope, ''), type: coalesce(rp.cat,'') }  }) END AS pub_syn,primary,parents,relationships,related_individuals,xrefs OPTIONAL MATCH (primary)-[rp:has_reference { typ: 'def'}]->(p:pub)  \nWITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p) } , PubMed: coalesce(p.PMID, ''), FlyBase: coalesce(p.FlyBase, ''), DOI: coalesce(p.DOI, '') } ) END AS def_pubs,primary,parents,relationships,related_individuals,xrefs,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary) } , description : coalesce(primary.description, []), comment : coalesce(primary.`annotation-comment`, []) } AS term, 'Get JSON for Class' AS query, '0f4d3af' AS version , parents, relationships, related_individuals, xrefs, pub_syn, def_pubs", "Get JSON for DataSet": "MATCH (primary:DataSet) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (s:Site { short_form: primary.self_xref })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: s.link_base, accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary OPTIONAL MATCH (s:Site)<-[dbx:hasDbXref]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: s.link_base, accession: coalesce(dbx.accession, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary OPTIONAL MATCH (primary)-[:has_license]->(l:License) \nWITH collect ({ icon : coalesce(l.license_logo, ''), link : coalesce(l.license_url, ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l) }  }) as license,primary,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub)  \nWITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p) } , PubMed: coalesce(p.PMID, ''), FlyBase: coalesce(p.FlyBase, ''), DOI: coalesce(p.DOI, '') } ) END AS pubs,primary,xrefs,license OPTIONAL MATCH (primary)<-[:has_source]-(i:Individual) WITH  i, primary, xrefs, license, pubs OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) \nWITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,primary,xrefs,license,pubs RETURN { link : coalesce(primary.dataset_link, ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary) } , description : coalesce(primary.description, []), comment : coalesce(primary.`annotation-comment`, []) } AS term, 'Get JSON for DataSet' AS query, '0f4d3af' AS version , xrefs, license, pubs, dataset_counts", "Get JSON for License": "MATCH (primary:License) WHERE primary.short_form in ['$ID']  \nWITH primary RETURN { icon : coalesce(primary.license_logo, ''), link : coalesce(primary.license_url, ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary) } , description : coalesce(primary.description, []), comment : coalesce(primary.`annotation-comment`, []) } AS term, 'Get JSON for License' AS query, '0f4d3af' AS version ", "Get JSON for Template": "MATCH (primary:Template) WHERE primary.short_form in ['$ID']  \nWITH primary MATCH (channel:Individual)<-[irw:in_register_with]-(channel:Individual)-[:depicts]->(primary) \nWITH { index: coalesce(irw.index, []) + [], extent: irw.extent, center: irw.center, voxel: irw.voxel, orientation: irw.orientation, image_folder: irw.folder, channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel) }  } as template_channel,primary OPTIONAL MATCH (technique:Class)<-[:is_specified_output_of]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(primary) WHERE has(irw.index) WITH primary, template_channel, collect ({ channel: channel, irw: irw}) AS painted_domains UNWIND painted_domains AS pd MATCH (channel:Individual { short_form: pd.channel.short_form})-[:depicts]-(ai:Individual)-[:INSTANCEOF]->(c:Class)  \nWITH collect({ anatomical_type: { short_form: c.short_form, label: coalesce(c.label,''), iri: c.iri, types: labels(c) }  , anatomical_individual: { short_form: ai.short_form, label: coalesce(ai.label,''), iri: ai.iri, types: labels(ai) } , folder: pd.irw.folder, center: coalesce (pd.irw.center, []), index: [] + coalesce (pd.irw.index, []) }) AS template_domains,primary,template_channel OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license]->(l:License) \nWITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link, ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds) }  }, license: { icon : coalesce(l.license_logo, ''), link : coalesce(l.license_url, ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l) }  }}) AS dataset_license,primary,template_channel,template_domains OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) } ) END AS parents ,primary,template_channel,template_domains,dataset_license OPTIONAL MATCH (o)<-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) }  }) END AS relationships ,primary,template_channel,template_domains,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: primary.self_xref })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: s.link_base, accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, template_channel, template_domains, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:hasDbXref]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: s.link_base, accession: coalesce(dbx.accession, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage, ''), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s) } , icon: coalesce(s.link_icon_url, ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,template_channel,template_domains,dataset_license,parents,relationships OPTIONAL MATCH (o:Individual)<-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o) }  }) END AS related_individuals ,primary,template_channel,template_domains,dataset_license,parents,relationships,xrefs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary) } , description : coalesce(primary.description, []), comment : coalesce(primary.`annotation-comment`, []) } AS term, 'Get JSON for Template' AS query, '0f4d3af' AS version , template_channel, template_domains, dataset_license, parents, relationships, xrefs, related_individuals"}